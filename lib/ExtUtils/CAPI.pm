package ExtUtils::CAPI;
use strict;
use warnings;

use DynaLoader;

our $VERSION = '0.01';

sub export_functions {
  my %opt = @_;
  my $module = $opt{module} // die "Need 'module' option";
  my $header = $opt{header} // die "Need 'header' option";
  my $functions = $opt{functions} // die "Need 'functions' option";
  $functions = {%$functions};
  
  my @func_names = keys %$functions;
  foreach my $funcname (@func_names) {
    my $func_ptr_type = $functions->{$funcname};
    my %func_def = (func_ptr_type => $func_ptr_type);

    ($func_def{func_ptr} = $func_ptr_type) =~ s/\(\s*\*\s*\)/(*${funcname}_ptr)/
      or die "Invalid function pointer type? '$func_ptr_type'";

    ($func_def{signature} = $func_ptr_type) =~ s/\(\s*\*\s*\)/($funcname)/
      or die "Failed to generate signature from function pointer type '$func_ptr_type' syntax";

    $functions->{$funcname} = \%func_def;
  }

  open my $hdr_fh, ">", $header
    or die "Cannot open header file '$header' for writing: $!";

  (my $guard = "CAPI_$module") =~ s/[^A-Za-z_]/_/g;
  print $hdr_fh "#ifndef $guard\n#define $guard\n";
  print $hdr_fh "/* This code is autogenerated. Do not edit it! */\n\n";

  my $module_name_define = $module;
  $module_name_define =~ s/::/_/g;
  $module_name_define =~ s/[^A-Za-z0-9_]/_/g;

  # Write out macro for defining the fptr symbols and
  # at the same time write out the actual fptr symbols as "extern"
  # declarations.
  SCOPE: {
    print $hdr_fh "\n";
    my @macro_code;
    foreach my $i (0 .. $#func_names) {
      my $funcname = $func_names[$i];
      my $code = $functions->{$funcname}->{func_ptr} . ";";
      push @macro_code, $code;
      print $hdr_fh "extern $code\n\n";
    }
    print $hdr_fh "\n";
    print $hdr_fh
      _make_macro("DEFINE_SYMBOLS_$module_name_define", @macro_code);
    print $hdr_fh "\n";
  }

  print $hdr_fh "\n\n";

  # Write out macro for initializing the fptrs.
  SCOPE: {
    my @macro_code;
    push @macro_code, <<'HERE';
  HV *symbols;
  I32 count;
  dSP;
  
  ENTER;
  SAVETMPS;
  PUSHMARK(SP);
HERE

    push @macro_code,
      "  EXTEND(SP, " . (scalar(@func_names)+1) . ");",
      "  PUSHs(sv_2mortal(newSVpvs(\"$module\")));",
      map {
        "  PUSHs(sv_2mortal(newSVpvs(\"$_\")));"
      } @func_names;
    push @macro_code, <<'HERE';
  
  PUTBACK;
  count = call_pv("ExtUtils::CAPI::_resolve_symbols", G_SCALAR);
  SPAGAIN;
  if (count != 1)
    croak("Failed to init symbols");
  
  symbols = (HV *)SvRV(POPs);
HERE

    foreach my $funcname (@func_names) {
      push @macro_code,
        "  ${funcname}_ptr = (void *)SvIV(*hv_fetchs(symbols, \"$funcname\", 0));";
    }

    push @macro_code, <<'HERE';
  PUTBACK;
  FREETMPS;
  LEAVE;
HERE

    print $hdr_fh "\n",
      _make_stmt_macro("INIT_SYMBOLS_$module_name_define", @macro_code), "\n";
  }

  print $hdr_fh "\n";

  print $hdr_fh "\n\n#endif\n";
  close $hdr_fh;
}

sub _make_stmt_macro {
  my ($name, @code) = @_;
  return _make_macro($name, "STMT_START {", @code, "} STMT_END");
}

sub _make_macro {
  my ($name, @code) = @_;
  my $code = join "\n", @code;
  $code =~ s/^/  /mg;
  $code =~ s/$/ \\/mg;
  $code =~ s/[\\\s]+\z//s;
  return "#define $name \\\n$code";
}


# Required for _resolve_symbols.
# Mostly lifted from DynaLoader.pm's bootstrap():
# Locates/opens lib files or dies trying.
sub find_lib {
  my ($module) = @_;

  my @modparts = split(/::/,$module);
  my $modfname = $modparts[-1];

  # Some systems have restrictions on files names for DLL's etc.
  # mod2fname returns appropriate file base name (typically truncated)
  # It may also edit @modparts if required.
  $modfname = &DynaLoader::mod2fname(\@modparts) if defined &DynaLoader::mod2fname;

  my $modpname = join('/',@modparts);
  my $file;
  my @dirs;
  foreach my $incdir (@INC) {
    my $dir = "$incdir/auto/$modpname";

    next unless -d $dir; # skip over uninteresting directories

    # check for common cases to avoid autoload of dl_findfile
    my $try = "$dir/$modfname.$DynaLoader::dl_dlext";
    last if $file = ($DynaLoader::do_expand) ? DynaLoader::dl_expandspec($try) : ((-f $try) && $try);

    # no luck here, save dir for possible later dl_findfile search
    push @dirs, $dir;
  }

  # last resort, let dl_findfile have a go in all known locations
  $file = DynaLoader::dl_findfile(map("-L$_", @dirs, @INC), $modfname) unless $file;
  if (not defined $file) {
    die "Failed to locate shared library for module '$module'";
  }
  return DynaLoader::dl_load_file($file);
}




# This is called from the generated C. Be extra careful about
# changing its visible behaviour.
sub _resolve_symbols {
  my ($module, @symbols) = @_;
  my $libhandle = find_lib($module);
  if (not defined $libhandle) {
    croak("Could not locate shared library for module '$module'");
  }
  my %syms;
  foreach my $symbol (@symbols) {
    my $sym = DynaLoader::dl_find_symbol($libhandle, $symbol);
    if (not defined $sym) {
      croak("Could not resolve symbol '$symbol' for module '$module'");
    }
    $syms{$symbol} = $sym;;
  }
  return \%syms;
}

sub include_path {
  require File::ShareDir;

  return join " ", map "-I$_", map File::ShareDir::dist_dir($_), @_;
}

1;

__END__

=head1 NAME

ExtUtils::CAPI - Export C functions between Perl XS modules

=head1 SYNOPSIS

  # sorry, no TL;DR, see below

=head1 DESCRIPTION

Defines a C API exported from a C/XS module that can be used from
other C/XS modules.

=head2 Defining the API

in F<Makefile.PL>:

    use ExtUtils::CAPI;
    ExtUtils::CAPI::export_functions(
      module => 'Some::Module',
      header => "some_module_api.h",
      functions => {
        some_module_function => 'int (*)(int, int)',
      },
    );

    # make sure some_module_api.h is installed, for example by using
    # File::ShareDir

in the F<.xs> file:

    #include "some_module_api.h"

    int
    some_module_function(int a, int b) {
        /* ... */
        return 0;
    }

    MODULE = Some::Module PACKAGE = Some::Package

    # ...

in the F<.pm> file:

    use ExtUtils::CAPI;

=head2 Using the API

in F<Makefile.PL>:

    WriteMakefile(
        NAME              => 'MyModule',
        # ...
        PREREQ_PM         => {
            'Some::Module' => 0,
        },
        # ...
        INC               => '-I. ' . '-I' . <path to some_module_api.h>,
    );

in the F<.xs> file:

    #include "some_module_api.h"

    DEFINE_SYMBOLS_Some_Module

    /* ... use some_module_function ... */

    MODULE = MyModule PACKAGE = MyModule

    BOOT:
      INIT_SYMBOLS_Some_Module;

    # ... use some_module_function

in the F<.pm> file:

    use Some::Module;

=head1 AUTHOR

Steffen Mueller, E<lt>smueller@cpan.orgE<gt>

Mattia Barbon, E<lt>mattia@barbon.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2014 by Steffen Mueller

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.

=cut
